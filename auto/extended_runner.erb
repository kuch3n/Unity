/*=======Extended Runner=====*/

#define BUF_SIZE 4096

typedef struct
{
    const char * classname;
    const char * name;
    const char * file;
    bool isFailed;
    bool isIgnored;
    bool isSkipped;
    int time;
    int line;
    int idx_msg;
    char msg[BUF_SIZE];
} UnityTestResult;

typedef struct
{
  UnityTestFunction func;
  const char* name;
  const char* file;
  const char* suite;
  UNITY_LINE_TYPE line_num;
  UnityTestResult result;
} UnityTestCase;

typedef struct
{
    const char* name;
    UnityTestCase * cases;
    UNITY_COUNTER_TYPE failures;
    UNITY_COUNTER_TYPE ignores;
    UNITY_UINT time;
    char timestamp[BUF_SIZE];
} UnityTestSuite;

struct
{
    bool printCases;
    bool printSuites;
    bool printReporters;
    char const * caseFilter;
} UnityArguments;

const char FILE_NAME[] = "<%= input_file %>";
UnityTestResult * TestResult;

bool UnityStringStartsWith(const char *pre, const char *str);
int UnityGetCommandLineOptions(int argc, const char* argv[]);
void UnityListTestCases(void);
int UnityExtendedEnd(void);
UNITY_UINT UnityTimeDiff(UNITY_TIME_TYPE start, UNITY_TIME_TYPE end);

static size_t getCountTestCases(UnityTestSuite const * const suite);
static size_t getCountTestFailures(UnityTestSuite const * const suite);
static size_t getCountTestIgnores(UnityTestSuite const * const suite);

UnityTestSuite UnityTestSuites[] = {
    {
        .name = "", .cases = (UnityTestCase[]) {
<% tests.each_with_index do |test, idx| %>
<% if (!@options[:use_param_tests]) || test[:args].nil? || test[:args].empty? %>
            { .func = <%= test[:test] %>, .name = "<%= test[:test] %>", .line_num = <%= test[:line_number] %>, .suite = NULL },
<% end %>
<% end %>
            {NULL, NULL, 0}},
    },
<% tests.each_with_index do |test, idx| %>
<% if (!@options[:use_param_tests]) || test[:args].nil? || test[:args].empty? %>
<% next %>
<% else %>
    {
        .name = "<%= test[:test] %>", .cases = (UnityTestCase[]) {
<% test[:args].each.with_index(1) do |args, arg_idx| %>
<%  %>
            { .func = runner_args<%= arg_idx %>_<%= test[:test] %>, .name = "<%= test[:test] %>[<%= arg_idx  %>]", .line_num = <%= test[:line_number] %>, .suite = "<%= test[:test] %>"  },
<% end %>
            {NULL, NULL, 0}},
    },
<% end %>
<% end %>
};

#define UNITY_TEST_SUITES sizeof(UnityTestSuites) / sizeof(UnityTestSuite)

int main(int argc, const char* argv[])
{
    int exit = 0;

    exit = UnityGetCommandLineOptions(argc, argv);

    if(UnityArguments.printCases)
    {
        UnityListTestCases();
    }

    if(exit == 1)
    {
        return 0;
    }

    UnityBegin(FILE_NAME);

    for(size_t idx = 0; idx < UNITY_TEST_SUITES; idx++)
    {
        UNITY_TIME_TYPE timeStart, timeStop;

        UnityTestCase * testCase = UnityTestSuites[idx].cases;
        time_t current_time;
        const struct tm * tm;
    
        current_time = time(NULL);
        tm = localtime(&current_time);
        // ToDo: Error Handling
        strftime(UnityTestSuites[idx].timestamp , sizeof(UnityTestSuites[idx].timestamp), "%Y-%m-%dT%H:%M:%S", tm);
        
        UNITY_GET_TIME(timeStart);

        while(testCase->func != NULL)
        {
            TestResult = &(testCase->result);

            TestResult->file = testCase->file;
            TestResult->classname = testCase->name;
            TestResult->name = testCase->name;
            TestResult->line = testCase->line_num;
            TestResult->isSkipped = false;
            TestResult->isIgnored = false;
            TestResult->isFailed = false;
            TestResult->time = 0;

            if(UnityArguments.caseFilter != NULL && strstr(UnityArguments.caseFilter, testCase->name) == NULL)
            {
                TestResult->isSkipped = true;
                testCase++;

                continue;
            }

            
            run_test(testCase->func, testCase->name, testCase->line_num);
            testCase++;
        }
        UNITY_GET_TIME(timeStop);

        UnityTestSuites[idx].time = UnityTimeDiff(timeStart, timeStop);
    }

    return UnityExtendedEnd();
}

#define VERSION "0.0.1"

int UnityGetCommandLineOptions(int argc, const char* argv[])
{
    int i;

    UnityArguments.caseFilter = NULL;
    UnityArguments.printCases = false;
    UnityArguments.printReporters = false;
    UnityArguments.printSuites = false;

    if(argc == 1)
    {
        return 0;
    }

    for(int i = 1; i < argc; i++)
    {
        if(strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0)
        {
            printf("doctest version is \"%s\"\n\n", VERSION);
            printf("-h,   --help             print this message\n");
            printf("-v,   --version          print the version\n");
            printf("-ltc, --list-test-cases  list all tests by name\n");
            printf("-lts, --list-test-suites list test suites\n");
            printf("-lr,  --list-reporters   list all registered reporters\n");
            printf("\n");
            printf("-tc,  --test-case=<filters>\n");
            printf("-ts,  --test-suite=<filters>\n");

            return 1; /* Exit without running tests */
        }
        else if(strcmp(argv[i], "-v") == 0 || strcmp(argv[i], "--version") == 0)
        {
            printf("doctest version is \"2.4.12\"\n");

            return 1;
        }
        else if(strcmp(argv[i], "-ltc") == 0 || strcmp(argv[i], "--list-test-cases") == 0)
        {
            UnityArguments.printCases = true;

            return 1;
        }
        else if(strcmp(argv[i], "-lts") == 0 || strcmp(argv[i], "--list-test-suites") == 0)
        {
            UnityArguments.printSuites = true;
            printf("ToDo: Not implemented\n");

            return 1;
        }
        else if(strcmp(argv[i], "-lr") == 0 || strcmp(argv[i], "--list-reporters") == 0)
        {
            UnityArguments.printReporters = true;
            printf("ToDo: Not implemented\n");

            return 1;
        }
        else if(strcmp(argv[i], "-tc") == 0)
        {
            if(i + 1 >= argc)
            {
                printf("No filter passed");
            }
            else
            {
                UnityArguments.caseFilter = argv[i + 1];
            }
            
            return 1;
        }
        else if(UnityStringStartsWith("--test-case=", argv[i]))
        {
            size_t offset = strlen("--test-case=");

            /* points to '\0' if no filter is given after argument */
            UnityArguments.caseFilter = &(argv[i][offset]);

            return 0;
        }
        else if(strncmp(argv[i], "-", 1) == 0 || strncmp(argv[i], "--", 2) == 0)
        {
            printf("Unknown command line arg: %s\n", argv[i]);
        }
        else
        {
            return 0;
        }
    }
}

bool UnityStringStartsWith(const char *pre, const char *str)
{
    size_t lenpre = strlen(pre),
           lenstr = strlen(str);
    return lenstr < lenpre ? false : memcmp(pre, str, lenpre) == 0;
}

void UnityListTestCases(void)
{
    printf("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");

    printf("<doctest binary=\"%s\" version=\"%s\">\n", __FILE__, VERSION);

    for(size_t idx = 0; idx < UNITY_TEST_SUITES; idx++)
    {
        bool inSuite = false;
        size_t cases = getCountTestCases(&(UnityTestSuites[idx]));

        if(strlen(UnityTestSuites[idx].name) > 0)
        {
            inSuite = true;
        }

        for(size_t idx_case = 0; idx_case < cases; idx_case++)
        {
            UnityTestCase const * _case = &(UnityTestSuites[idx].cases[idx_case]);

            printf("  <TestCase");
            printf(" name=\"%s\"", _case->name);
            if(inSuite == true)
            {
                printf(" testsuite=\"%s\"", UnityTestSuites[idx].name);
            }
            printf(" filename=\"%s\"", FILE_NAME);
            printf(" line=\"%u\"", _case->line_num);
            printf(" skipped=\"false\"");
            printf("/>\n");
        }
    }

    printf("</doctest>\n");
}

UNITY_UINT UnityTimeDiff(UNITY_TIME_TYPE start, UNITY_TIME_TYPE end)
{
    UNITY_UINT diff;
    
    diff = ((end.tv_sec - start.tv_sec) * 1000L);
    diff += ((end.tv_nsec - start.tv_nsec) / 1000000L);

    return diff;
}

static size_t getCountTestCases(UnityTestSuite const * const suite)
{
    size_t count = 0;
    UnityTestCase const * testCase;

    testCase = suite->cases;
    while(testCase->func != NULL)
    {
        testCase++;
        count++;
    }

    return count;
}

static size_t getCountTestFailures(UnityTestSuite const * const suite)
{
    size_t failures = 0;
    UnityTestCase const * testCase;

    testCase = suite->cases;
    while(testCase->func != NULL)
    {
        testCase++;
        if(testCase->result.isFailed)
        {
            failures++;
        }
    }

    return failures;
}

static size_t getCountTestIgnores(UnityTestSuite const * const suite)
{
    size_t ignores = 0;
    UnityTestCase const * testCase;

    testCase = suite->cases;
    while(testCase->func != NULL)
    {
        testCase++;
        if(testCase->result.isIgnored)
        {
            ignores++;
        }
    }

    return ignores;
}

int UnityExtendedEnd(void)
{
    UNITY_UINT time;

    UNITY_PRINT_EOL();
    
    
    UnityTestSuite const * suite = UnityTestSuites;

    printf("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    printf("<doctest binary=\"%s\" version=\"%s\">\n", __FILE__, VERSION);

    for(size_t idx = 0; idx < UNITY_TEST_SUITES; idx++)
    {
        size_t cases = getCountTestCases(suite);

        printf("  <TestSuite");
        if(strlen(suite->name) > 0)
        {
            printf(" name=\"%s\"", suite->name);
        }
        printf(">\n");

        for(size_t idx_case = 0; idx_case < cases; idx_case++)
        {
            UnityTestResult * result = &suite->cases[idx_case].result;

            printf("    <TestCase");
            printf(" name=\"%s\"", result->name);
            printf(" classname=\"%s\"", result->classname);
            printf(" assertions=\"0\"");
            printf(" time=\"%u\"", result->time);
            printf(" filename=\"%s\"", FILE_NAME);
            if(result->isSkipped)
            {
                printf(" skipped=\"%s\"", "true");
            }
            printf(" line=\"%u\"", result->line);
            printf(">\n");
            
            if(!result->isFailed && !result->isSkipped)
            {
                printf("      <OverallResultsAsserts successes=\"0\" failures=\"0\" test_case_success=\"true\"/>\n");
            }

            if(result->isFailed)
            {
                printf("      <Message type=\"FATAL ERROR\" filename=\"%s\" line=\"%u\">\n", FILE_NAME, result->line);
                printf("        <Text>\n");
                printf("          %s\n", result->msg);
                printf("        </Text>\n");
                printf("      </Message>\n");
                printf("      <OverallResultsAsserts successes=\"0\" failures=\"1\" test_case_success=\"false\"/>\n");
            }


            
            printf("    </TestCase>\n");
            
        }

        printf("  </TestSuite>\n");

        suite++;
    }

    printf("</doctest>\n");

    UNITY_FLUSH_CALL();
    UNITY_OUTPUT_COMPLETE();
    return (int)(Unity.TestFailures);
}